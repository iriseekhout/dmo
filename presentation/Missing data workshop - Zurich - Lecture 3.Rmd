---
title: "Lecture 3"
author: "Dr. Iris Eekhout"
subtitle: "Missing data"
date: "Zurich - 27 & 28 June 2022"
output: 
  ioslides_presentation:
    logo: Puzzle_zgnb3_m.jpg
    theme: readable
    css: eigencssfile.css
widescreen: true
always_allow_html: yes
---

```{r setup, include = F}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, comment = ">")

library(mice)
library(lavaan)
library(dplyr)
library(semTools)
library(tidyr)
library(miceadds)
library(broom.mixed)
library(lme4)
library(dmo)

```



# Multiple imputation (recap) {data-background=Puzzle_zgnb3.jpg data-background-size=cover}
 
## Multiple Imputation

* Imputation phase
* Analysis phase
* Pooling phase

> 1. incomplete data
> 2. generate multiple copies of the same dataset, but each time differenty imputed values
> 3. analyze each imputed dataset
> 4. pool results for analyses to final study result

## Notes on multiple imputation

* Takes imputation uncertainty into account
* A method to improve the main analysis results, (so not to complete or fill in data)
* Make sure that the **imputation model**
  + Holds the relevant variables to deal with missings
  + Is compatible with the analysis model


# Full Information Maximum Likelihood {data-background=Puzzle_zgnb3.jpg data-background-size=cover}

## How does it work

* Uses all observed data, so also partly observed rows, to estimate model parameters.
* Analysis and dealing with missing data, at once
* Different ways to estimate, for example EM algorithm
* Only involves variables used in the analysis


## FIML in `lavaan` {.smaller}

* In R use `lavaan` package with `missing = "fiml"`.

```{r echo=TRUE}
model <- '
  #variance
  Ozone ~~ Ozone
  Solar.R ~~ Solar.R
  Wind ~~ Wind
  Temp ~~ Temp
  
  #correlation
  Ozone ~~ Solar.R + Wind + Temp
  Solar.R ~~ Wind + Temp
  Wind ~~ Temp
  '
fit <- sem(model, data = airquality, missing = "fiml", meanstructure = TRUE)
```

## FIML descriptives {.smaller}


```{r echo=FALSE}
summary(fit, standardized = TRUE, header = FALSE)
```


## Output explained {.smaller}

Output is quite large and gives a lot of information at once. 

* Intercepts: FIML means 
  + *~1* in output tables 
* Variance: FIML variances 
  + *variable x ~~ variable x* in output tables
* Covariances: FIML correlation (because `standardized = TRUE`) 
  + *variable x ~~ variable y* in output tables


Use `fmi = TRUE` in the `summary()` function to get fraction of missing information. 

fmi = the relative increase in variance and decrease of precision due to missing data, i.e. impact of missing data on estimates.

## Missing data patterns 

* Missing data patterns in the data

```{r}

inspect(fit, 'patterns') 

```


## Missing data proportions

* A symmetric matrix where each element contains the proportion of observed datapoints for the corresponding pair of observed variables.

```{r}
inspect(fit, 'coverage')
```

## Linear regression analysis {.smaller}

```{r}
model <- '
  Ozone ~ Solar.R 
  '
fit_fiml <- sem(model, data = airquality, missing = "fiml")
summary(fit_fiml, header = FALSE, fmi = TRUE)
```

## Compare with MI {.smaller}

```{r}
imp_pmm <- mice(airquality %>% select(Ozone, Solar.R), method = "pmm", print = F)
fit_mi <- with(imp_pmm, lm(Ozone ~ Solar.R))
combi <- pool(fit_mi)
summary(combi)
```

## SEM with auxiliary variables {.smaller}

* Use auxiliary variables to improve missing data handling
* Auxiliary variables to covariances in the model

```{r}
model_aux <- '
  Ozone ~ Solar.R 
  Solar.R ~~ Wind + Temp + Month + Day
  Ozone ~~ Wind + Temp + Month + Day
  Wind ~~ Temp + Month + Day
  Temp ~~ Month + Day
  Month ~~ Day
  '
auxfit1 <- sem(model = model_aux, missing = "fiml", data = airquality)
```

## SEM with auxiliary variables {.smaller}

```{r, echo = FALSE}
summary(auxfit1, header = FALSE, fmi = TRUE)
```



## SEM with auxiliary variables {.smaller}

* Easily add auxiliary variables with `semTools` package

```{r}
aux.vars <- c("Wind", "Temp", "Month","Day")
auxfit <- sem.auxiliary(model=model, missing = "fiml", aux=aux.vars, fixed.x=FALSE, data=airquality)

```


## SEM with auxiliary variables {.smaller}

```{r echo = FALSE}
summary(auxfit, header = FALSE, fmi = TRUE)

```


## Compare with MI {.smaller}

```{r}
imp_pmm <- mice(airquality, method = "pmm", print = F)
fit_mi <- with(imp_pmm, lm(Ozone ~ Solar.R))
combi <- pool(fit_mi)
summary(combi)          
  
```



# Mssing data in questionnaires {data-background=Puzzle_zgnb3.jpg data-background-size=cover}

## Multi-item questionnaires

* Constructs measured indirectly, through items.
* Item can be continuous, dichotomous or measured on Likert scale.
* Summary score of items is the construct

## Summarizing item scores

* CTT: sum score or mean score
* Latent variable obtained via Item Response model (e.g. Rasch model or 2 parameter logistic model)
* Latent variable measured in a structural equation model

## Missing data in multi-item questionnaires

* Missing item level scores
* Missing full questionnaire

```{R echo=FALSE}
data.frame(item1 = c(1,NA,NA), item2 = c(0,1,NA), item3 = c(0, 0, NA), item4 = c(0,NA, NA), item5 = c(1, 1, NA), "Total score"=c(2, NA, NA) )

```

**Both lead to a missing total score**


## Advice in user manuals

* User manuals often have a statement about dealing with missing items scores
* This method is not always evidence-based
* Examples:
  + SF-36: "*Items that are left blank (missing data) are not taken into account when calculating the scale scores. Hence, scale scores represent the average for all items in the scale that the respondent answered.*" (Ware & Sherbourne, 1992)
  + SDQ: "*The SDQ comprises of 5 items for 5 subscales. For each of the 5 scales the score can range from 0 to 10 if all items were completed. These scores can be scaled up pro-rata if at least 3 items were completed, e.g. a score of 4 based on 3 completed items can be scaled up to a score of 7 (6.67 rounded up) for 5 items."* (Goodman, 2010)
  

## Person mean imputation

* Single imputation of mean over the observed items (within person)
* Same as average over the available items
* Best ad hoc single imputation method available
* Disadvantages of single imputation: no imputation uncertainty
* Works best when correlation between items is higher

## Example of person mean imputation {.build .smaller}

```{r include=FALSE}

#generate questionnaire data
k <- c(5,5)
x <- dmo::gen_qdata(n=20, k= k, likert = T)

#generate covariate data
set.seed(61085)
cov <- MASS::mvrnorm(n=20, mu=c(5,5,5), Sigma=matrix(c(10,1,1,1,10,1,1,1,10),3,3))
colnames(cov) <- c("cov1", "cov2", "cov3")

#combine in data.frame
x1 <- data.frame(cbind(x,cov))

alpha <- 0.25

#regerate 2 random patterns for missing item data
pattern <- matrix(c(sample(c(0,1), size=2*sum(k),replace = TRUE)),nrow=2)
pattern <- cbind(pattern, matrix(c(1,1,1,1,1,1),nrow=2, byrow = T))
pattern

#apply each pattern with equal frequency and equal odds
f <- c(0.5,0.5)
g <- c(4,4)

#generate missings in the data
set.seed(9817)
x <- MAR(x1,alpha = alpha ,pattern = pattern, f = f ,g = g)
colnames(x) <- gsub("_", "",colnames(x1))

#head(x, 15)
ts <- dmo::calculate_ts(x, k= c(5,5))
data <- data.frame(x,ts) %>% select(Q1i1:Q2i5, TSQ1, TSQ2, cov1) %>% mutate(cov1 = round(cov1, 2))
data
```

```{r echo=FALSE}
x <-data[1:5,c(1:5, 11)]
x
```

```{r echo=TRUE}
x %>% 
  #compute average over available items (AAI)
  mutate(AAI = rowMeans(select(.,Q1i1, Q1i2, Q1i3, Q1i4, Q1i5), na.rm = T)) %>%
  #then apply rule to all items that if the score is missing, to replace it with AAI
   mutate_at(.vars = vars(Q1i1:Q1i5),
             .funs = list(~ ifelse(is.na(.), AAI, .))) %>%
  mutate(TSQ1 = rowSums(select(.,Q1i1, Q1i2, Q1i3, Q1i4, Q1i5)))
```

## Note on person mean imputation

* Can get unstable when:
  + Many items are missing.
  + Correlations between items is low.
* Single imputation method, no missing data uncertainty.

## Multiple imputation in multi-item questionnaires

* Imputing item scores versus imputing total scores
* Item scores can hold valuable information
* Total scores are often used in analyses

## Advised strategy for imputation

* When there are item scores observed, use item level imputation
* When only few item scores or none, use total score imputation
* Combine both strategies

## Challenges in multi-item questionnaire missings

* Imputation model can grow large when all items are used
* When the total score is used in analyses, the total score should be used as predictor for other variables

## Solutions 

*Imputation model can grow large when all items are used*

* Isolate item imputation per questionnaire or subscale via prediction matrix
* Especially relevant in longitudinal data

*When the total score is used in analyses, the total score should be used as predictor for other variables*

* Update total score after each iteration by using **passive imputation**.

## Illustration item and total scores {.smaller}

* Data set with two questionnaires each 5 items, and 1 covariate.
* Isolate item imputation per questionnaire or subscale.
* Use predictor matrix: rows indicate imputed variable, columns are predictors.

For Q1:
```{r}
predQ <- make.predictorMatrix(data)
predQ[1:5,6:10] <- 0
predQ[1:5,]
```


## Illustration item and total scores {.smaller}

* Isolate item imputation per questionnaire or subscale

For Q2:
```{r}
predQ[6:10,1:5] <- 0
predQ[6:10,]
```

## Illustration item and total scores {.smaller}

* Total score cannot be used as predictor for its own items.

```{r}
predQ[1:5,11] <- 0
predQ[6:10,12] <- 0

predQ[1:10,]

```


## Illustration item and total scores {.smaller}

* Item scores cannot be used as predictor together with its own total scores.

```{r}
predQ[11:13,1:10] <- 0
predQ[11:13,]
```


## Illustration item and total scores {.smaller}


* Total score should be used as predictor for other variables when used in the analysis model.

```{r}
predQ[11:13,11:13]
```


## Illustration item and total scores {.smaller}

* Full predictor matrix

```{r}
predQ

```



## Passive imputation total score

* Total score is used as predictor, but not directly imputed.
* Item scores are imputed.
* Total scores re-calculated from the imputed item scores: **Passive imputation**


## Passive imputation process {.smaller .build}

**During each iteration for Q1:**

1\. Impute item scores using items from its own questionnaire, total score(s) from other questionnaires and covariate(s).

  * $Q1i1_i = Q1i2_i + Q1i3_i + Q1i4_i + Q1i5_i + TSQ2_i + cov1_i$
  * $Q1i2_i = Q1i1_i + Q1i3_i + Q1i4_i + Q1i5_i + TSQ2_i + cov1_i$
  * $etc.$
  
2\. Total score is re-calculated using the imputed item scores.

  * $TSQ1_i = Q1i1_i + Q1i2_i + Q1i3_i + Q1i4_i + Q1i5_i$
  
3\. Updated total score is used as predictor for covariate(s) and items of other questionnaires in next iteration.

  * $Q2i1_i =  Q2i2_i + Q2i3_i + Q2i4_i + Q2i5_i + TSQ1_i + cov1_i$


*Note the $_i$ indicates impute value from the previous iteration.*

## Passive imputation code {.smaller .build}

* Change the imputation method for the total scores.

```{r}
imp0 <- mice(data, pred = predQ, m =1, maxit =0)
methodQ <- imp0$method
methodQ[c("TSQ1", "TSQ2")]
```

```{r}
methodQ["TSQ1"] <- "~I(Q1i1 + Q1i2 + Q1i3 + Q1i4 + Q1i5)"
methodQ["TSQ2"] <- "~I(Q2i1 + Q2i2 + Q2i3 + Q2i4 + Q2i5)"
methodQ[c("TSQ1", "TSQ2")]

```


## Missing data in IRT models

* Some of the estimation methods for IRT methods deal with missing values by MAR assumption
* For example maximum likelihood estimation


## Missing data in SEM models

* Full Information Maximum Likelihood estimation
* In `R` the `lavaan` package - simulates Mplus


## Missing item scores

* Item level information may need a different strategy in order to use all available information
* When there are missing values at item level only, use a strategy that involves the item scores.
* When mostly the full questionnaire is missing, the missing data can be dealt with at the total score level.



```{R include = FALSE}

cov <- matrix(0.8, nrow = 3, ncol = 3)
diag(cov) <- 1
set.seed(24672)
out <- MASS::mvrnorm(n = 50, mu = c(0,1,2), Sigma = cov)
wideex <- data.frame(id = 1:50,
           group = rep(c(0,1), 25),
           out) %>%
  rename(T0 = X1, T1 = X2, T2 = X3)

longex <- wideex %>% pivot_longer(cols = T0:T2, names_to = "time", values_to = "outcome")

#make missings
wideexm <- dmo::MCAR(wideex, alpha = 0.25, pattern = matrix(c(1,1,1,1,0,
                                                              1,1,1,0,0,
                                                              1,1,1,0,1,
                                                              1,1,0,1,0), byrow = T, ncol = 5), f = c(0.25,0.25,0.25,0.25))
wideexm <- data.frame(wideexm)
colnames(wideexm) <- colnames(wideex)

longexm <- wideexm %>% pivot_longer(cols = T0:T2, names_to = "time", values_to = "outcome") 
rvar <- runif(150)
longexmc <- longexm %>%
  mutate(cov1 = runif(n()),
         cov2 = rnorm(n()),
         cov3 = rnorm(n()),
         cov1 = ifelse(rvar > 0.75, NA, cov1))

wideexmc <- longexmc %>%
  pivot_wider(id_cols = c(id, group), names_from = "time", values_from = c("outcome", "cov1", "cov2", "cov3"))
```

# Longitudinal missing data {data-background=Puzzle_zgnb3.jpg data-background-size=cover}

## Repeated measurements data

* In longitudinal studies people are monitored for a longer time period.
* For example RCT with follow-up.
  + Baseline
  + Post-treatment
  + Follow-up
* Intensive longitudinal data: sensor measurements, daily measures.


## Challenges

* Multiple variables at each time-point
* Repeated measurements are correlated within persons: multilevel structure
* Measurement time-points some times do not line up

## Data structure

* Wide data format
  + One row per person, repeated measurements in the columns
* Long data format
  + Multiple rows per person, one column as time-point indicator
  
## Wide data format

```{R echo=FALSE}
head(wideex, 15)
```


## Long data format

```{R echo = FALSE}
longex <- wideex %>% 
  pivot_longer(cols = T0:T2, names_to = "time", values_to = "outcome") %>% 
  as.data.frame
head(longex, 15)
 
```

## Missing data imputation

* Wide imputation
* Long imputation: multilevel imputation


## Wide data imputation

* Similar to multiple imputation on cross-sectional data
* Number of variables in imputation model may be a challenge
* Imputation model ~ analysis model


## Example wide imputation

Data set for two groups with measurements at three time-points for:

* outcome
* covariate 1
* covariate 2
* covariate 3


In total: 13 variables in wide imputation. Can grow large when more variables are measured at each time-point.

## Practical solution for wide imputation {.smaller}

* Leave out covariates from other time-points as predictors in imputation model
* Adapt the predictormatrix

Example predictormatrix for cov1 

```{r}
### change to have covs for T0 to outcome T0 and covs for T1 to uotcome T1 etx.
wide_pred <- mice::make.predictorMatrix(wideexmc)
wide_pred["cov1_T0", c("cov2_T1","cov2_T2","cov3_T1","cov3_T2")] <- 0
wide_pred["cov1_T1", c("cov2_T0","cov2_T2","cov3_T0","cov3_T2")] <- 0
wide_pred["cov1_T2", c("cov2_T0","cov2_T1","cov3_T0","cov3_T1")] <- 0
wide_pred[c("cov1_T0", "cov1_T1", "cov1_T2"), 3:14]
```

## Imputation of long data

* Multilevel imputation
* Account for the clustering of measurements within subjects

## Methods for multilevel imputation

* `miceadds` package contains many additional methods
* `broom.mixed` to enable the `pool` function for the mice output.

## Long imputation predictormatrix {.smaller}

* Use `-2` for cluster variable `id` in predictormatrix (random intercept)

```{r}
long_pred <- mice::make.predictorMatrix(longexmc)
long_pred[c(2:7), "id"] <- (-2)
long_pred

```

## Long imputation method {.smaller}

* Change method to `2l.pmm`

```{r}
ini <- mice(longexmc, m = 1, maxit = 0, pred = long_pred)
long_meth <- ini$method
long_meth[c("outcome", "cov1")] <- "2l.pmm"
long_meth

```

## FIML for missing outcomes

* Missings in dependent variable solved in Maximum likelihood estimation
  + $Outcome = \beta_0 + \beta_1*cov2 + b_{0j} + \epsilon_{ij}$
  + $b_{0j}$ is random intercept at subject level
* Estimation method optimizes model parameter using *all* observed data of dependent variable

*Missing covariate data are handled by listwise deletion*

## Example no imputation {.smaller}

* Only cov1 has missing data
* Outcome variable has missing observations (drop-out)

```{r}
md.pattern(longexmc, plot = F)
```

```{r}
fit1 <- lme4::lmer(outcome ~ cov2 + (1|id), data = longexmc)
tidy(fit1, conf.int = T)

```

## Example with imputation

* Impute the outcome (and cov1) as comparison.

```{r message=FALSE, warning=FALSE}
mlimp <- mice(longexmc, m = 5, maxit = 10, method = long_meth, pred = long_pred, print = F, seed = 899)
fitmi <- with(mlimp, lmer(outcome ~ cov2 + (1|id)))
combi <- pool(fitmi)
summary(combi)
```
